{"version":3,"sources":["components/word.tsx","components/tooltip/index.tsx","components/icon.tsx","components/tags/index.tsx","utils.ts","parser/word.ts","types.ts","parser/query.ts","parser/lexer.ts","components/wordTable/header.tsx","storage/index.ts","query/expr.ts","query/insert.ts","query/stmt.ts","components/modal/index.tsx","components/wordcard/index.tsx","components/wordTable/wordTable.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["ps","className","map","p","i","wp","key","Piece","text","kana","Description","desc","split","s","children","active","ele","tooltip","props","icon","aria-hidden","TagComponent","tag","onDelete","name","onDoubleClick","tags","onAddition","t","id","allowNew","allowBackspace","tagComponent","autoResize","placeholderText","serializeWordPieces","join","printWord","w","content","description","printWordEntries","ws","printWords","value","downloadVocabulary","filename","element","document","createElement","setAttribute","encodeURIComponent","style","display","body","appendChild","click","removeChild","download","Token","lexer","buildLexer","Character","LParen","RParen","apply","tok","v","Text","rep_sc","Annot","kmid","seq","opt_sc","anno","Pieces","vs","parseWordPieces","input","expectSingleResult","expectEOF","parse","trim","ExprType","AtomType","Op","StmtType","TokenImpl","kind","pos","keep","nextToken","undefined","this","parseNextAvailable","index","length","rowEnd","columnEnd","LexerImpl","rules","_rules","rule","source","Error","global","indexStart","rowBegin","columnBegin","result","subString","substr","regexp","lastIndex","test","TokenError","slice","token","parseNext","makeVal","type","Atom","constant","b","Const","makeBin","op","l","r","Binop","prev","opparser","Insert","Delete","Orderby","Slice","True","False","Number","And","Or","Add","Minus","Multiply","Divide","LessEq","GreaterEq","Less","Greater","Equal","Colon","Variable","Tag","Space","Line","WordInfo","Tags","list_sc","nil","kright","alt","words","Boolean","T","Num","Constant","Var","TagExpr","BinopTable","Expr","ExprParser","str","f","reduce","p1","p2","lrec_sc","right","setPattern","SliceIndex","n1","n2","start","end","Stmt","Stmts","EmptyExpr","MainExpr","Query","expr","stmts","parser","parseQuery","query","Buttons","onClick","toggleHide","export","NewWord","addWord","init","cancel","useState","rtags","setRtags","descRef","useRef","contRef","setActive","resetEditor","current","focus","cancelEdit","setError","useEffect","error","create","then","e","console","log","filter","_","j","onKeyDown","insertParens","ref","placeholder","metaKey","ctrlKey","Filter","tref","execute","txt","rows","onFocus","onBlur","idx","selectionStart","selectionEnd","vocabulary","localforage","createInstance","saveWord","word","a","setItem","SESSIONCOUNT","Date","now","toString","newword","reviewtime","lastreview","Promise","all","updateWord","getItem","update","listWords","cond","iterate","push","delWord","removeItem","evalAtom","includes","getTime","Math","round","random","evalExpr","lres","rres","evalBin","executeInsert","insertEntries","forEach","Array","isArray","Object","keys","S","delStmt","execStmt","compute","resolve","values","sort","e1","e2","sortBy","orderbyStmt","composeStmtFuns","fs","res","ts","onClose","card","Card","_prevWord","prevWord","_nextWord","nextWord","review","reviewed","widx","uncover","setUncover","hasPrev","hasNext","disableCls","cls","since","momentjs","fromNow","topRef","tabIndex","title","disabled","tagReview","setWords","hide","setHide","_setWIdx","refreshSt","refresh","editing","setEditing","vocabSize","setVocabSize","busy","setBusy","setWIdx","nw","wi","ow","editWord","task","Q","newwords","activate","del","edit","Entry","valign","stopPropagation","Controls","App","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.43a2ca17.chunk.js","sourcesContent":["import React from 'react'\nimport * as T from '../types'\n\ntype Props = {ps: T.WordPieces}\n\nexport default ({ps}: Props) => {\n    return(\n        <span className=\"word-pieces\">\n            {ps.map((p, i) => (<Piece wp={p} key={i}/>))}\n        </span>\n    )\n}\n\nconst Piece = ({wp}: {wp: T.WordPiece}) => {\n    if (typeof wp === \"string\"){\n        return (<ruby>{wp}</ruby>)\n    }\n    const {text, kana} = wp\n    return (<ruby>{text} <rt>{kana}</rt> </ruby>)\n}\n\nexport const Description = ({desc}:{desc: string}) => {\n    return(\n        <>{desc.split(\"\\n\").map((s, i) => <p key={i}>{s}</p>)}</>\n    )\n}","import React, {useState} from 'react'\nimport './tooltip.scss'\n\ntype Props = {children: [JSX.Element, JSX.Element], active: boolean}\n\nexport default ({children, active}: Props)=>{\n    const [ele, tooltip] = children\n    return(\n        <div className={active ? \"tooltip-wrapper active\": \"tooltip-wrapper\"}>\n            <div \n                className={active ? \"tooltip-ele active\" : \"tooltip-ele\"} \n            >\n                {ele}\n            </div>\n            <div className=\"tooltip-tooltip\">\n                {tooltip}\n            </div>\n        </div>\n    )\n}","import React from 'react'\nimport '@fortawesome/fontawesome-free/css/all.css'\n\nexport default (props: {icon: string}) => {\n    const {icon} = props\n    return (<i {...props} className={`fa fa-${icon}`} aria-hidden=\"true\" />)\n}","import React from 'react'\nimport ReactTags from 'react-tag-autocomplete'\n\nimport './tags.scss'\n\n\n\nconst TagComponent = ({ tag, onDelete}: {tag: {name: string}, onDelete: any}) => {\n    return (\n      <div className=\"word-tag\">\n        {tag.name}\n        <span className=\"word-tag-del\" onDoubleClick={onDelete}>✕</span>\n      </div>\n    )\n}\n\ntype Props = {\n      tags: string[]\n    , onDelete: (i:number)=>void\n    , onAddition: (tag: {name: string})=>void\n    }\n\nexport default ({tags, onDelete, onAddition}: Props) => {\n\n    return(\n        <ReactTags \n            tags={tags.map(t=>({id: t, name: t}))}\n            onDelete={onDelete}\n            onAddition={onAddition}\n            allowNew={true}\n            allowBackspace={false}\n            tagComponent={TagComponent}\n            autoResize={true}\n            placeholderText=\"       \"\n        />\n    )\n}","\nimport * as T from './types'\n\nexport function serializeWordPieces(ps: T.WordPieces): string {\n    return ps.map(p => typeof p===\"string\"? p : (p.text + \"(\" + p.kana + \")\")).join('')\n}\n\nfunction printWord(w: T.WordInfo): string{\n    const tags = w.tags.map(t => '#'+t).join(' ')\n    return [tags, serializeWordPieces(w.content), w.description, tags].join('\\n')\n}\n\nfunction printWords(ws: T.WordInfo[]): string{\n    return ws.map(printWord).join('\\n')\n}\n\nfunction printWordEntries(ws: T.WordEntry[]): string{\n    return \"Insert\\n\" + printWords(ws.map(w => w.value))\n}\n\nexport function downloadVocabulary(ws: T.WordEntry[]){\n    download(\"query.txt\", printWordEntries(ws))\n}\n\nfunction download(filename: string, text: string) {\n    var element = document.createElement('a');\n    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));\n    element.setAttribute('download', filename);\n    element.style.display = 'none';\n    document.body.appendChild(element);\n    element.click();\n    document.body.removeChild(element);\n  }\n\n","import { Parser } from 'typescript-parsec';\nimport { buildLexer, expectEOF, expectSingleResult } from 'typescript-parsec';\nimport { opt_sc, apply, kmid, rep_sc, seq, str, tok } from 'typescript-parsec';\nimport * as T from '../types'\n\nenum Token {\n      Character\n    , LParen\n    , RParen\n}\n\nconst lexer = buildLexer([\n    [true, /^[^()]/g, Token.Character],\n    [true, /^\\(/g, Token.LParen],\n    [true, /^\\)/g, Token.RParen],\n])\n\ntype P<T> = Parser<Token, T>\n\nconst Character: P<string> = apply(tok(Token.Character), v => v.text)\n\nconst Text: P<string> = apply(rep_sc(Character), v=>v.join(''))\n\nconst Annot: P<string> = kmid(tok(Token.LParen), Text, tok(Token.RParen))\n\nconst Piece: P<T.WordPiece> = \n    apply(seq(Character, opt_sc(Annot)),\n        ([t, anno]) => (anno ? {text: t, kana: anno}: t))\n\nexport const Pieces: P<T.WordPieces> = \n    apply(seq(Piece, rep_sc(Piece)), ([v, vs]) => [v, ...vs])\n\nexport function parseWordPieces(input: string): T.WordPieces{\n    return expectSingleResult(expectEOF(Pieces.parse(lexer.parse(input.trim()))))\n}\n","export type Kanji = {text: string, kana: string}\n\nexport type WordPiece = Kanji | string\n\nexport type WordPieces = WordPiece[]\n\nexport type WordInfo = {\n    content: WordPieces\n  , description: string\n  , tags: string[]\n}\n\nexport type Word = WordInfo & {reviewtime: number, lastreview: Date}\n\nexport type KeyValue<T> = {key: string, value: T}\n\nexport type WordEntry = KeyValue<Word> & {reviewed: boolean}\n\n\nexport type Tag = string\n\nexport enum ExprType{\n    Atom\n  , Binop\n}\n\n\nexport enum AtomType{\n    Tag\n  , Var\n  , Const\n}\ntype AtomSkelton<T, V> = {type: ExprType.Atom, t: T, v: V}\ntype TagAtm = AtomSkelton<AtomType.Tag, string>\ntype VarAtm = AtomSkelton<AtomType.Var, string>\ntype BoolConst = AtomSkelton<AtomType.Const, boolean>\ntype NumConst = AtomSkelton<AtomType.Const, number>\nexport function makeVal<T, V>(t: T, v: V): AtomSkelton<T, V>{\n  return ({type: ExprType.Atom, t, v})\n}\nexport function constant<T>(b: T): AtomSkelton<AtomType.Const, T>{\n  return makeVal(AtomType.Const, b)\n}\nexport type Atom = TagAtm | VarAtm | BoolConst | NumConst\n\n\nexport enum Op {\n  And\n, Or\n, Add\n, Minus\n, Divide\n, Multiply\n, Equal\n, Less\n, Greater\n, LessEq\n, GreaterEq\n}\nexport type Binop = {type: ExprType.Binop, op: Op, l: Expr, r: Expr}\nexport function makeBin(op: Op): (l: Expr, r: Expr)=>Binop{\n  return (l, r) => ({type:ExprType.Binop, op, l, r})\n}\n\nexport type Expr = Binop | Atom\n\nexport type Insert = {\n    type: \"Insert\"\n  , words: (Omit<WordInfo, \"tags\"> | Tag[])[]\n}\n\nexport enum StmtType{\n    Delete\n  , Orderby\n  , Slice\n}\nexport type Delete = {type: StmtType.Delete}\nexport type Orderby = {type: StmtType.Orderby, value: Expr}\nexport type Slice = {type: StmtType.Slice, start: number | undefined, end: number | undefined}\nexport type Stmt = \n  Delete | Orderby | Slice\n\nexport type Stmts = Stmt[]\n\n\nexport type Filter = {\n    type: \"Filter\"\n  , expr: Expr \n  , stmts: Stmts\n}\n\nexport type Query = Insert | Filter\n\nexport type Result = number | boolean","import { kright, Parser, kleft, list_sc, rule, str, lrec_sc } from 'typescript-parsec';\nimport {expectSingleResult, expectEOF } from 'typescript-parsec';\nimport { opt_sc, nil, apply, kmid, rep_sc, seq, tok, alt } from 'typescript-parsec';\nimport {parseWordPieces} from './word'\nimport {buildLexer} from './lexer'\n// import {buildLexer} from 'typescript-parsec'\nimport * as T from '../types'\n\n\nenum Token {\n      Insert\n    , LParen\n    , RParen\n    , Tag\n    , Space\n    , Line\n    , And\n    , Or\n    , True\n    , False\n    , Number\n    , Add\n    , Minus\n    , Divide\n    , Multiply\n    , Equal\n    , Less\n    , Greater\n    , LessEq\n    , GreaterEq\n    , Variable\n    , Delete\n    , Slice\n    , Orderby\n    , Colon\n}\n\nconst lexer = buildLexer([\n    [true, /^Insert/gi, Token.Insert],\n    [true, /^Delete/gi, Token.Delete],\n    [true, /^Orderby/gi, Token.Orderby],\n    [true, /^Slice/gi, Token.Slice],\n    [true, /^true/gi, Token.True],\n    [true, /^false/gi, Token.False],\n    [true, /^\\d+(\\.\\d+)?/g, Token.Number],\n    [true, /^[&]{2}/g, Token.And],\n    [true, /^[|]{2}/g, Token.Or],\n    [true, /^[+]/g, Token.Add],\n    [true, /^[-]/g, Token.Minus],\n    [true, /^[*]/g, Token.Multiply],\n    [true, /^[/]/g, Token.Divide],\n    [true, /^[<][=]/g, Token.LessEq],\n    [true, /^[>][=]/g, Token.GreaterEq],\n    [true, /^[<]/g, Token.Less],\n    [true, /^[>]/g, Token.Greater],\n    [true, /^[=]{2}/g, Token.Equal],\n    [true, /^[:]/g, Token.Colon],\n    [true, /^\\$[a-zA-Z0-9]+/g, Token.Variable],\n    [true, /^\\(/g, Token.LParen],\n    [true, /^\\)/g, Token.RParen],\n    // keep at last\n    [true, /^\\#[a-zA-Z0-9]+/g, Token.Tag],\n    [false, /^[\\s]+/g, Token.Space],\n    [true, /^[^\\s][^\\n]*/g, Token.Line],\n])\n\ntype P<T> = Parser<Token, T>\n\nconst Line: P<string> = apply(tok(Token.Line), t => t.text)\n\n\nconst WordInfo: P<Omit<T.WordInfo, \"tags\">> = \n    apply(seq(Line, Line),\n        ([content, description]) => ({content: parseWordPieces(content), description}))\n\nconst Tag: P<T.Tag> = apply(tok(Token.Tag), v => v.text.substr(1))\n\nconst Tags: P<T.Tag[]> = list_sc(Tag, nil())\n\nconst Insert: P<T.Insert> = \n    kright(tok(Token.Insert), apply(rep_sc(alt(WordInfo, Tags)), words=>({type: \"Insert\", words})))\n\n// Expression\nconst Boolean = alt(apply(tok(Token.True), ()=>T.constant(true)), \n                    apply(tok(Token.False), ()=>T.constant(false)))\nconst Num = apply(tok(Token.Number), t => +t.text)\nconst Number = apply(Num, t => T.constant(t))\nconst Constant = alt(Boolean, Number)\nconst Variable = apply(tok(Token.Variable), v=>T.makeVal(T.AtomType.Var as T.AtomType.Var, v.text.substr(1)))\nconst TagExpr = apply(Tag, t=>T.makeVal(T.AtomType.Tag as T.AtomType.Tag, t))\nconst Atom: P<T.Atom> = alt(TagExpr, Constant, Variable)\ntype BinopInfo = [Token, (l: T.Expr, r: T.Expr)=>T.Expr]\nconst BinopTable: BinopInfo[][] = [\n    [[Token.Multiply, T.makeBin(T.Op.Multiply)], [Token.Divide, T.makeBin(T.Op.Divide)]],\n    [[Token.Add, T.makeBin(T.Op.Add)], [Token.Minus, T.makeBin(T.Op.Minus)]],\n    [\n        [Token.Equal, T.makeBin(T.Op.Equal)],\n        [Token.Less, T.makeBin(T.Op.Less)],\n        [Token.Greater, T.makeBin(T.Op.Greater)],\n        [Token.GreaterEq, T.makeBin(T.Op.GreaterEq)],\n        [Token.LessEq, T.makeBin(T.Op.LessEq)],\n    ],\n    [[Token.And, T.makeBin(T.Op.And)]],\n    [[Token.Or, T.makeBin(T.Op.Or)]],\n\n]\nconst Expr = rule<Token, T.Expr>();\nconst Term = alt(Atom, kmid(str('('), Expr, str(')')))\n\nlet ExprParser: P<T.Expr> = Term\n\n\nfunction makeOpParesr(opinfo: BinopInfo[]){\n    return opinfo.map(([t, f]) => apply(tok(t), ()=>f)).reduce((p1, p2)=>alt(p1, p2))\n}\nfunction makeParser(prev: P<T.Expr>, opparser: P<(l:T.Expr, r: T.Expr)=>T.Expr>){\n    return lrec_sc(prev, seq(opparser, prev), (l: T.Expr, right)=> right[0](l, right[1]))\n}\nfor(const opinfo of BinopTable){\n    const opparser = makeOpParesr(opinfo)\n    ExprParser = makeParser(ExprParser, opparser) \n}\n\nExpr.setPattern(ExprParser)\n\n// Statement parser\nconst Delete: P<T.Delete> = apply(tok(Token.Delete), ()=>({type: T.StmtType.Delete}))\nconst Orderby: P<T.Orderby> = \n    apply(kright(tok(Token.Orderby), Expr)\n    , value =>({type: T.StmtType.Orderby, value}))\nconst SliceIndex = seq(opt_sc(Num), tok(Token.Colon), opt_sc(Num))\nconst Slice: P<T.Slice> = apply(\n    kright(tok(Token.Slice), SliceIndex)\n    , ([n1, _, n2]) => ({type: T.StmtType.Slice, start: n1, end: n2})\n    )\nconst Stmt: P<T.Stmt> = alt(Delete, Orderby, Slice)\nconst Stmts: P<T.Stmts> = rep_sc(Stmt)\n\nconst EmptyExpr: P<T.Expr> = apply(nil(), ()=>T.constant(true))\n\nconst MainExpr: P<T.Expr> = alt(Expr, EmptyExpr)\n\nconst Query: P<T.Query> = alt(\n      Insert\n    , apply(seq(MainExpr, Stmts), ([expr, stmts]) => ({type: \"Filter\", expr, stmts}))\n    )\n\n\nexport function parse<T>(parser: P<T>) {\n    return ((input: string) => {\n        // const res = expectEOF(parser.parse(lexer.parse(input)))\n        // console.log(res.successful ? res.candidates : res.error)\n        return expectSingleResult(expectEOF(parser.parse(lexer.parse(input))));\n    }\n    );\n}\n\nexport const parseQuery = parse(Query)\n","import { Lexer, Token, TokenPosition, TokenError } from 'typescript-parsec';\n\nclass TokenImpl<T> implements Token<T> {\n    private nextToken: Token<T> | undefined | null;\n\n    constructor(\n        private readonly lexer: LexerImpl<T>,\n        private readonly input: string,\n        public kind: T,\n        public text: string,\n        public pos: TokenPosition,\n        public keep: boolean\n    ) {\n    }\n\n    public get next(): Token<T> | undefined {\n        if (this.nextToken === undefined) {\n            this.nextToken = this.lexer.parseNextAvailable(\n                this.input,\n                this.pos.index + this.text.length,\n                this.pos.rowEnd,\n                this.pos.columnEnd\n            );\n            if (this.nextToken === undefined) {\n                this.nextToken = null;\n            }\n        }\n\n        return this.nextToken === null ? undefined : this.nextToken;\n    }\n}\n\nclass LexerImpl<T> implements Lexer<T> {\n    _rules: [boolean, RegExp, T][]\n    constructor(public rules: [boolean, RegExp, T][]) {\n        for (const rule of this.rules) {\n            if (rule[1].source[0] !== '^') {\n                throw new Error(`Regular expression patterns for a tokenizer should start with \"^\": ${rule[1].source}`);\n            }\n            if (!rule[1].global) {\n                throw new Error(`Regular expression patterns for a tokenizer should be global: ${rule[1].source}`);\n            }\n        }\n        this._rules = rules\n    }\n\n    public parse(input: string): TokenImpl<T> | undefined {\n        this.rules = this._rules\n        return this.parseNextAvailable(input, 0, 1, 1);\n    }\n\n    public parseNext(input: string, indexStart: number, rowBegin: number, columnBegin: number): TokenImpl<T> | undefined {\n        if (indexStart === input.length) {\n            return undefined;\n        }\n\n        const subString = input.substr(indexStart);\n        let result: TokenImpl<T> | undefined;\n        for (const [keep, regexp, kind] of this.rules) {\n            regexp.lastIndex = 0;\n            if (regexp.test(subString)) {\n                const text = subString.substr(0, regexp.lastIndex);\n                let rowEnd = rowBegin;\n                let columnEnd = columnBegin;\n                for (const c of text) {\n                    switch (c) {\n                        case '\\r': break;\n                        case '\\n': rowEnd++; columnEnd = 1; break;\n                        default: columnEnd++;\n                    }\n                }\n\n                result = new TokenImpl<T>(this, input, kind, text, { index: indexStart, rowBegin, columnBegin, rowEnd, columnEnd }, keep);\n                break\n            }\n        }\n\n        if (result === undefined) {\n            throw new TokenError(\n                { index: indexStart, rowBegin, columnBegin, rowEnd: rowBegin, columnEnd: columnBegin },\n                `Unable to tokenize the rest of the input: ${input.substr(indexStart)}`\n            );\n        } else {\n            if (/^insert/gi.test(result.text)){\n                this.rules = this.rules.slice(-3)\n            }\n            return result;\n        }\n    }\n\n    public parseNextAvailable(input: string, index: number, rowBegin: number, columnBegin: number): TokenImpl<T> | undefined {\n        let token: TokenImpl<T> | undefined;\n        while (true) {\n            token = this.parseNext(\n                input,\n                (token === undefined ? index : token.pos.index + token.text.length),\n                (token === undefined ? rowBegin : token.pos.rowEnd),\n                (token === undefined ? columnBegin : token.pos.columnEnd)\n            );\n            if (token === undefined) {\n                return undefined;\n            } else if (token.keep) {\n                return token;\n            }\n        }\n    }\n}\n\nexport function buildLexer<T>(rules: [boolean, RegExp, T][]): Lexer<T> {\n    return new LexerImpl<T>(rules);\n}","import React, {useState, useRef, useEffect} from 'react'\nimport './header.scss'\nimport Tooltip from '../tooltip'\nimport Icon from '../icon'\nimport Tags from '../tags'\nimport * as T from '../../types'\nimport {serializeWordPieces} from '../../utils'\nimport {parseWordPieces, parseQuery} from '../../parser'\n\n\ntype Props = {\n      addWord: AddWord\n    , init: T.WordInfo | null\n    , cancel: ()=>void\n    , toggleHide: ()=>void\n    , query: (q: T.Query)=>void\n    , export: () => void\n}\n\ntype AddWord = (w: T.WordInfo)=>Promise<void>\n\nexport default (props: Props) => {\n    return(\n        <div className=\"header\">\n            <Buttons {...props}/>\n            <Filter query={props.query}/>\n        </div>\n    )\n}\n\nconst Buttons = (props: Props) =>{\n    return(\n        <div className=\"header-buttons\">\n            <NewWord {...props}/>\n            <button onClick={props.toggleHide}><Icon icon=\"eye-slash\"/></button>\n            <button onClick={props.export}><Icon icon=\"file-download\"/> </button>\n        </div>\n    )\n}\n\nconst NewWord = ({addWord, init, cancel}: Props) => {\n    const [rtags, setRtags] = useState([] as string[])\n    const descRef = useRef() as React.MutableRefObject<HTMLTextAreaElement>\n    const contRef = useRef() as React.MutableRefObject<HTMLInputElement>\n\n    const [active, setActive] = useState(false)\n\n    const resetEditor = () => {\n        contRef.current.value=\"\"\n        descRef.current.value=\"\"\n        contRef.current.focus()\n    }\n\n    const cancelEdit = () => {\n        setActive(false)\n        setError(false)\n        cancel()\n    }\n    \n    useEffect(()=>{\n        if (init === null){\n            resetEditor()\n        } else {\n            setActive(true)\n            setError(false)\n            descRef.current.value = init.description\n            contRef.current.value = serializeWordPieces(init.content)\n            setRtags(init.tags)\n        }\n    }, [init])\n\n    const [error, setError] = useState(false)\n    const delTag = (i:number) =>{\n        setRtags(rtags.filter((_, j)=>j!==i))\n    }\n    const addTag = (tag: {name: string})=>{\n        setRtags([...rtags, tag.name])\n    }\n    const parenShortcut = (e: React.KeyboardEvent) =>{\n        if (e.key===\"Escape\"){\n            insertParens(contRef)\n        }\n        setError(false)\n    }\n\n    const handleTextAreaKey = (e: React.KeyboardEvent) => {\n        if ((e.metaKey || e.ctrlKey) && e.key === \"Enter\"){\n            create()\n        }\n    }\n    const create = () => {\n        try{\n            const content = parseWordPieces(contRef.current.value)\n            const description = descRef.current.value\n            addWord({content, description, tags: rtags})\n            .then(() => {resetEditor(); if (init !== null) cancelEdit()})\n        } catch(e){\n            setError(true)\n            console.log(e)\n        }\n    }\n    return(\n        <Tooltip active={active}>\n            <button \n                onClick={() => active ? cancelEdit() : setActive(true)} \n                className=\"add\"\n            ><Icon icon=\"plus\"/></button>\n\n            <div\n            className=\"newword-form\">\n                <Tags \n                    tags={rtags}\n                    onDelete={delTag}\n                    onAddition={addTag}\n                />\n\n                <div className=\"label\">Word</div>\n                <input \n                    onKeyDown={parenShortcut} \n                    ref={contRef} \n                    type=\"text\" \n                    className={error ? \"word-input error\" : \"word-input\"}\n                    placeholder=\"e.g. 見(み)る. Press [Esc] to insert ()\"\n                />\n                <div className=\"label\">Definition</div>\n                <textarea onKeyDown={handleTextAreaKey} ref={descRef}/>\n                <div className=\"buttons\">\n                    <button className=\"save\" onClick={create}><Icon icon=\"save\"/></button>\n                    <button className=\"cancel\" onClick={cancelEdit}><Icon icon=\"ban\"/></button>\n                </div>\n            </div>\n        </Tooltip>\n    )\n}\n\n\nconst Filter = ({query}: {query: (q:T.Query)=>void}) => {\n    const [active, setActive] = useState(false)\n    const tref = useRef() as React.MutableRefObject<HTMLTextAreaElement>\n    const execute = ()=>{\n        if (tref.current) {\n            const txt = tref.current.value\n            query(parseQuery(txt))\n        }\n    }\n    const onKeyDown = (e: React.KeyboardEvent)=>{\n        if (e.key === \"Escape\"){\n            insertParens(tref)\n        }\n        if ((e.metaKey || e.ctrlKey) && e.key === \"Enter\"){\n            execute()\n        }\n    }\n    return(\n        <div className=\"header-query\">\n            <textarea \n                onKeyDown={onKeyDown}\n                ref={tref}\n                rows={active ? 20 : 1}\n                placeholder=\"Input query\"\n                onFocus={()=>setActive(true)}\n                onBlur={()=>setActive(false)}\n            />\n            <span\n                className=\"icon\"\n                onClick={execute}\n                ><Icon icon=\"search\"/></span>\n        </div>\n    )\n}\n\n\nfunction insertParens(ref: React.MutableRefObject<HTMLInputElement | HTMLTextAreaElement>){\n    const idx = ref.current.selectionStart\n    if (idx !== null){\n        const text = ref.current.value\n        ref.current.value=text.slice(0, idx) + \"()\" + text.slice(idx)\n        ref.current.selectionStart = idx + 1\n        ref.current.selectionEnd = idx + 1\n    }\n}","\nimport localforage from 'localforage'\nimport * as T from '../types'\n\nconst vocabulary = localforage.createInstance({\n    name: \"vocabulary\"\n  });\n\nexport async function saveWord(key: string, word: T.Word){\n    await vocabulary.setItem(key, word)\n    return key\n}\n\nlet SESSIONCOUNT = 0\n\nexport async function addWord(word: T.WordInfo){\n    const key = Date.now().toString() + \".\" + (SESSIONCOUNT ++)\n    const newword: T.Word = {...word, reviewtime: 1, lastreview: new Date()}\n    await saveWord(key, newword)\n    return {key, value: newword} as T.KeyValue<T.Word>\n}\n\nexport async function addWords(words: T.WordInfo[]){\n    return await Promise.all(words.map(addWord))\n}\n\nexport async function updateWord(key: string, f: (w:T.Word)=> T.Word){\n    const newword = f(await vocabulary.getItem(key) as T.Word)\n    await saveWord(key, newword)\n    return newword\n}\n\nexport async function reviewWord(key: string){\n    const update = (w: T.Word) => {\n        w.reviewtime += 1\n        w.lastreview = new Date()\n        return w\n    }\n    return await updateWord(key, update)\n}\n\nexport async function updateWordField<K extends keyof T.Word, V extends T.Word[K]>(key: string, field: K, val: V){\n    const update = (w: T.Word) => {\n        w[field] = val\n        return w\n    }\n    return await updateWord(key, update)\n}\n\nexport async function listWords(test ?: (w: T.Word)=>boolean){\n    var words: T.KeyValue<T.Word>[] = []\n    const cond = test ? test : (()=>true)\n    await vocabulary.iterate((value: T.Word, key)=>{\n        if (cond(value)){\n            words.push({key, value})\n        }\n    })\n    return words\n}\n\n\nexport async function delWord(key: string){\n    return await vocabulary.removeItem(key)\n}\n\nexport async function vocabularySize(){\n    return await vocabulary.length()\n}","import * as T from '../types';\n\nfunction diffDays(n1: number, n2: number) {\n    return Math.round((n1 - n2) / (1000 * 60 * 60 * 24));\n}\n\nexport function evalAtom(v: T.Atom, w: T.Word): T.Result {\n    switch (v.t) {\n        case T.AtomType.Tag:\n            return w.tags.includes(v.v);\n        case T.AtomType.Var:\n            switch (v.v) {\n                case \"review\": return w.reviewtime;\n                case \"days\": return diffDays(Date.now(), w.lastreview.getTime());\n                case \"rand\": return Math.random();\n                default: throw Error(`Unknown variable ${v.v}`);\n            }\n        case T.AtomType.Const:\n            return v.v;\n    }\n}\n\n\n\nexport function evalBin(op: T.Op, l: T.Result, r: T.Result): T.Result {\n    if (typeof l === \"number\" && typeof r === \"number\") {\n        switch (op) {\n            case T.Op.Add: return l + r;\n            case T.Op.Minus: return l - r;\n            case T.Op.Multiply: return l * r;\n            case T.Op.Divide: return l / r;\n            case T.Op.LessEq: return l <= r;\n            case T.Op.GreaterEq: return l >= r;\n            case T.Op.Less: return l < r;\n            case T.Op.Greater: return l > r;\n        }\n    }\n    if (typeof l === \"boolean\" && typeof r === \"boolean\") {\n        switch (op) {\n            case T.Op.And: return l && r;\n            case T.Op.Or: return l || r;\n        }\n    }\n\n    if (typeof l === typeof r) {\n        switch (op) {\n            case T.Op.Equal: return l === r;\n        }\n    }\n\n    throw Error(`Incmpatible type of binary operator`);\n\n}\n\nexport function evalExpr(expr: T.Expr) {\n    return (w: T.Word): T.Result => {\n        switch (expr.type) {\n            case T.ExprType.Atom:\n                return evalAtom(expr, w);\n            case T.ExprType.Binop:\n                const lres = evalExpr(expr.l)(w);\n                const rres = evalExpr(expr.r)(w);\n                return evalBin(expr.op, lres, rres);\n        }\n    };\n}\n","import * as T from '../types';\nimport * as S from '../storage';\n\n\nexport function executeInsert(insertEntries: T.Insert[\"words\"]) {\n    let tags: { [t: string]: null; } = {};\n    let words: T.WordInfo[] = [];\n    insertEntries.forEach(e => {\n        if (Array.isArray(e)) {\n            e.forEach(t => { if (t in tags) { delete tags[t]; } else { tags[t] = null; } });\n        } else {\n            words.push({ ...e, tags: Object.keys(tags) });\n        }\n    });\n    return S.addWords(words);\n}\n","import * as T from '../types'\nimport * as S from '../storage'\nimport {evalExpr} from './expr'\n\ntype StmtFun = (ws: T.WordEntry[]) => Promise<T.WordEntry[]>\n\nasync function delStmt(ws: T.WordEntry[]){\n    await Promise.all(ws.map(w => S.delWord(w.key)))\n    return []\n}\n\nfunction sortBy<T>(a: T[], f: (e:T)=>number): T[]{\n    const values:[number, T][] = a.map(e => [f(e), e])\n    values.sort((e1, e2) => e1[0]-e2[0])\n    return values.map(e=>e[1])\n}\n\nfunction orderbyStmt(expr: T.Expr): StmtFun{\n    const compute = (w: T.WordEntry) => evalExpr(expr)(w.value) as number\n    return (ws: T.WordEntry[]) => new Promise(resolve => resolve(sortBy(ws, compute)))\n}\n\nfunction sliceStmt(start: number | undefined, end: number | undefined): StmtFun{\n\n    return (ws: T.WordEntry[]) => \n        new Promise(resolve => resolve(ws.slice(\n            start === undefined ? 0 : start, \n            end === undefined ? ws.length : end)))\n}\n\nconst id: StmtFun = ws => (new Promise(resolve => resolve(ws)))\n\nfunction execStmt(t: T.Stmt): StmtFun{\n    switch (t.type){\n        case T.StmtType.Delete:\n            return delStmt\n        case T.StmtType.Orderby:\n            return orderbyStmt(t.value)\n        case T.StmtType.Slice:\n            return sliceStmt(t.start, t.end)\n    }\n}\n\nfunction composeStmtFuns(fs: StmtFun[]): StmtFun{\n    return (ws: T.WordEntry[])=>{\n        let res = id(ws)\n        for(const f of fs){\n            res = res.then(f)\n        }\n        return res\n    }\n}\n\nexport async function execStmts(ts: T.Stmts, ws: T.WordEntry[]){\n    return await composeStmtFuns(ts.map(execStmt))(ws)\n}","import React from 'react'\nimport './modal.scss'\n\ntype Props = {content: JSX.Element | null, onClose: ()=>void}\nexport default ({content, onClose}: Props) =>{\n    if (content === null) {return (<></>)}\n    return(\n        <div \n            className=\"modal\" \n            // tabIndex={0}\n            onKeyDown={e=>{if (e.key===\"Escape\") onClose()}}\n        >\n            <div className=\"modal-content\">\n                {content}\n            </div>\n        </div>\n    )\n}\n","import React, {useEffect, useRef, useState} from 'react'\nimport momentjs from 'moment'\nimport Modal from '../modal'\nimport * as T from '../../types'\nimport './wordcard.scss'\nimport Content, {Description} from '../word'\nimport Icon from '../icon'\n\n\ntype Props = {\n      word: T.WordEntry\n    , nextWord: ()=>void\n    , prevWord: ()=>void\n    , onClose: ()=>void\n    , review: ()=>void\n    , index: {widx: number, length: number}\n}\n\nexport default (props: Props) => {\n    const {word, onClose} = props\n    const card = word === null ? null : (<Card {...props}/>)\n    return(\n        <Modal content={card} onClose={onClose}/>\n    )\n}\n\nconst Card = ({word, prevWord: _prevWord, nextWord: _nextWord, onClose, review, index}: Props)=>{\n    const {value:{content, description, tags, lastreview, reviewtime}, reviewed} = word\n    const {widx, length} = index\n\n    const [uncover, setUncover] = useState(false)\n\n    const hasPrev = widx > 0\n    const hasNext = widx < length - 1\n    const disableCls = (test: boolean, cls: string) => cls + (test ? \" disabled\" :  \"\")\n\n    const prevWord = () => {setUncover(false); _prevWord()}\n    const nextWord = () => {setUncover(false); _nextWord()}\n\n\n    const since = momentjs(lastreview).fromNow()\n\n    const topRef = useRef(null as HTMLDivElement | null)\n\n    useEffect(()=>{\n        topRef.current?.focus()\n    }, [])\n\n    const handleKeydown = (e: React.KeyboardEvent<HTMLDivElement>) => {\n        switch (e.key){\n            case \"a\":\n                prevWord()\n                break\n            case \"s\":\n                review()\n                break\n            case \"d\":\n                nextWord()\n                break\n            case \"w\":\n                setUncover(true)\n                break\n        }\n    }\n\n    return(\n        <div \n            className={reviewed? \"wordcard-wrapper reviewed\" : \"wordcard-wrapper\"}\n            onKeyDown={handleKeydown}\n            tabIndex={0}\n            ref={topRef}\n        >\n            <button className=\"close\" \n                    onClick={onClose}\n            >&times;</button>\n            <div className=\"info\">\n                Reviewed {since}\n            </div>\n            <div className=\"wordcard-nav\">\n\n                <div className=\"wordcard\">                    \n                    <div className={\"content\" + (uncover ? \" uncover\": \"\")}>\n                        <Content ps={content}/>\n                    </div>\n                    <div className=\"tags\">\n                        {tags.map((t, i)=><span key={i}>{t}</span>)}\n                    </div>\n                    <div className=\"description\">\n                        <Description desc={description}/>\n                    </div>\n                    <div className=\"buttons\">\n                        <button title=\"S\" disabled={reviewed} onClick={review}>Review {reviewtime}</button>\n                    </div>\n                </div>\n                <div className={disableCls(hasPrev, \"nav-left\")} onClick={prevWord} title=\"A\">\n                    <Icon icon=\"chevron-left\"/>\n                </div>\n                <div className={disableCls(hasNext, \"nav-right\")} onClick={nextWord} title=\"D\">\n                    <Icon icon=\"chevron-right\"/>\n                </div>\n                <div className =\"index\">\n                    {widx+1} / {length}\n                </div>\n            </div>\n        </div>\n    )\n}\n","import React, {useState, useEffect} from 'react';\nimport * as T from '../../types'\nimport Word from '../word'\nimport Header from './header'\nimport './wordTable.scss'\nimport * as S from '../../storage'\nimport * as Q from '../../query'\nimport WordCard from '../wordcard'\nimport Icon from '../icon'\nimport {downloadVocabulary} from '../../utils'\n\ntype Props = {}\n\nfunction tagReview(w: T.KeyValue<T.Word>):T.WordEntry{\n    return {...w, reviewed: false}\n}\n\nexport default ({}: Props) => {\n    const [words, setWords] = useState([] as T.WordEntry[])\n    const [hide, setHide] = useState(false)\n    const [widx, _setWIdx] = useState(null as number | null)\n    const [refreshSt, refresh] = useState(false)\n    const [editing, setEditing] = useState(null as number | null)\n    const [vocabSize, setVocabSize] = useState(0)\n    const [busy, setBusy] = useState(false)\n\n    useEffect(()=>{S.vocabularySize().then(setVocabSize)})\n\n    useEffect(()=>{\n        S.listWords().then(ws => setWords(ws.map(tagReview)))\n    }, [])\n\n    const setWIdx = (i: number | null) => {\n        if (i === null) _setWIdx(null)\n        else if (0 <= i && i < words.length) _setWIdx(i)\n    }\n\n    const addWord = (w: T.WordInfo) => {\n        return S.addWord(w).then(wi => setWords([tagReview(wi), ...words]))\n    }\n\n    const editWord = (i: number) => {\n        const key = words[i].key\n        return (w: T.WordInfo) => {\n            return S.updateWord(key, ow => ({...ow, ...w}))\n            .then((nw)=>{words[i].value=nw;refresh(!refreshSt)})\n        }\n    }\n\n    const delWord = (i: number) => {\n        return () => {\n            S.delWord(words[i].key).then(() => {\n                setWords(words.filter((_,j)=>i!==j))\n            })\n        }\n    }\n\n    const review = (i: number | null) => {\n        if (i !==null && !words[i].reviewed) {\n            const key = words[i].key\n            S.reviewWord(key)\n            .then((nw)=>{\n                words[i]={key, value: nw, reviewed: true}\n                refresh(!refreshSt)\n            })\n        }\n    }\n\n    const executeQuery = (query: T.Query) => {\n        // console.log(query)\n        setBusy(true)\n        let task: Promise<void>\n        switch(query.type){\n            case \"Insert\":\n                task = Q.executeInsert(query.words).then(\n                    newwords => {\n                        setWords([...newwords.map(tagReview), ...words])\n                    }\n                )\n                break\n            case \"Filter\":\n                task = S.listWords(Q.evalExpr(query.expr) as (w: T.Word)=>boolean)\n                    .then(ws => Q.execStmts(query.stmts, ws.map(tagReview)))\n                    .then(setWords)\n                break\n        }\n        task.then(()=>setBusy(false))\n    }\n\n    return(\n        <div className={(hide? \"hide\" : \"\") + (busy? \" busy\" : \"\")}>\n        <div className=\"vocabulary\">\n            <Header \n                addWord={editing === null ? addWord : editWord(editing)}\n                init={editing === null ? null : words[editing].value}\n                cancel={()=>setEditing(null)}\n                toggleHide={()=>setHide(!hide)}\n                query={executeQuery}\n                export={()=>downloadVocabulary(words)}\n            />\n            <div className=\"table_info\">\n                {words.length} out of {vocabSize} words selected.\n            </div>\n            <table className=\"word-table\">\n                <thead>\n                    <tr>\n                        <th>Word</th>\n                        <th>Description</th>\n                        <th>Tags</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    {words.map((w, i) => (\n                        <Entry \n                            word={w} \n                            key={w.key}\n                            activate={()=>{setWIdx(i)}}\n                            del={delWord(i)}\n                            review={()=>review(i)}\n                            edit={()=>setEditing(i)}\n                        />))\n                    }\n                </tbody>\n            </table>\n        </div>\n        {(widx!==null)?\n        <WordCard\n            onClose={()=>{setWIdx(null)}}\n            nextWord={()=>{setWIdx(widx+1)}}\n            prevWord={()=>{setWIdx(widx-1)}}\n            review={()=>review(widx)}\n            word={words[widx]}\n            index={{widx, length: words.length}}\n        />: <></>}\n        </div>\n    )\n}\n\n\nconst Entry = ({\n    word, activate, del, review, edit}: \n    {word: T.WordEntry, activate: ()=>void, del: ()=>void, review: ()=>void, edit: ()=>void}) => {\n    const {content, tags, description} = word.value\n    const reviewed = word.reviewed\n    return(\n        <tr onClick={activate} className={reviewed ? \"reviewed\" : \"\"}>\n            <td><div className=\"content\">{<Word ps={content}/>}</div></td>\n            <td><div className=\"description\">{description}</div></td>\n            <td valign=\"top\">\n                <div className=\"tags\">\n                    {tags.map((t, i)=><span key={i}>{t}</span>)}\n                </div>\n            </td>\n            <td onClick={e=>e.stopPropagation()}>\n                <Controls del={del} review={review} reviewed={reviewed} edit={edit}/>\n            </td>\n        </tr>\n    )\n}\n\n\nconst Controls = ({del, review, reviewed, edit}\n                : {del: ()=>void, review: ()=>void, reviewed: boolean, edit: ()=>void}) => \n{\n    return(\n        <div className=\"controls\">\n            <button \n                className=\"edit\"\n                onClick={edit}\n            ><Icon icon=\"pen-alt\"/></button>\n            <button \n                className=\"review\"\n                onClick={review}\n            ><Icon icon={reviewed ? \"book-open\" : \"book\"}/></button>\n            <button \n                className=\"delete\"\n                onDoubleClick={del}\n                ><Icon icon=\"trash-alt\"/>\n            </button>\n        </div>\n    )\n}\n","import React from 'react';\nimport WordTable from './components/wordTable/wordTable'\nimport './App.css';\n\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <WordTable/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}